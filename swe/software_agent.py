# software_agent.py
import os
import torch
import logging
import json
from dataclasses import dataclass
from typing import List, Dict, Optional, Any
from transformers import AutoTokenizer
from swe.swe_actions import ActionRegistry, register_actions
from open_strawberry_torch.model import (
    TransformerPolicyNetwork as PolicyModel, 
    TransformerRewardModel as RewardModel,
    TransformerValueNetwork as ValueModel
)
from open_strawberry_torch.train import ThoughtTree, monte_carlo_rollout
from loguru import logger

@dataclass
class Context:
    response: str
    project_directory: str
    entities: Dict[str, Any]

class SoftwareEngineeringAgent:
    def __init__(
        self,
        project_directory: str,
    ):
        logging.basicConfig(
            filename='agent.log',
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
        self.project_directory = project_directory
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        # Initialize Action Registry
        self.action_registry = register_actions()
        self.action_id_to_name: Dict[int, str] = {
            idx: name for idx, name in enumerate(self.action_registry.list_actions())
        }

        self.action_history: List[str] = []  # Initialize action history list
        self.state_file = os.path.join(self.project_directory, 'agent_state.json')
        self.code_files: List[Dict[str, str]] = []
        logger.debug(f"SoftwareEngineeringAgent initialized with project_directory: {self.project_directory}")  # {{ edit_11 }}

    def get_code_files(self) -> List[str]:
        """
        Get the current state representation as a list of code files.

        Returns:
            List[str]: List of code file contents.
        """
        code_files = []
        for root, _, files in os.walk(self.project_directory):
            for file in files:
                if file.endswith('.py') or file.endswith('.txt') or file.endswith('.md'):
                    file_path = os.path.join(root, file)
                    with open(file_path, 'r', encoding='utf-8') as f:
                        code_text = f.read()
                        code_files.append(f"File: {file}\n{code_text}\n")
        return code_files

    def map_response_to_actions(self, response: str) -> List[str]:
        """
        Maps the model's response text to a list of actionable action names.

        Args:
            response (str): The response text generated by the model.

        Returns:
            List[str]: A list of action names to be executed.
        """
        actions = []

        # Define a list of all possible actions to ensure accurate mapping
        possible_actions = {
            "create_file": ["create a file", "create file", "generate file"],
            "generate_content": ["generate content", "write content"],
            "add_function": ["add function", "implement function"],
            "edit_file": ["edit file", "modify file"],
            "write_tests": ["write tests", "add tests"],
            "handle_code_insertion": ["insert code", "add code"],
            "run_tests": ["run tests", "execute tests"],
            "generate_docs": ["generate docs", "create documentation"],
            "safe_execute_code": ["execute code", "run code"],
            "commit_changes": ["commit changes", "push to repository"],
            "code_review": ["perform code review", "review code", "conduct code review"],
        }

        import re

        for action_name, keywords in possible_actions.items():
            for keyword in keywords:
                pattern = re.compile(r'\b' + re.escape(keyword) + r'\b', re.IGNORECASE)
                if pattern.search(response):
                    actions.append(action_name)
                    break

        exact_actions = [
            action.strip() for action in response.split(",") 
            if action.strip() in possible_actions
        ]
        if exact_actions:
            actions.extend(exact_actions)

        return list(set(actions))

    def execute_action(self, action_name: str, context: Context):
        """
        Executes an action based on the action name.
    
        Args:
            action_name (str): The action name to execute.
            context (Context): The context for the action.
        """
        action = self.action_registry.get_action(action_name)
        if action:
            try:
                action.execute(context.response, context)
                self.logger.info(f"Executed action: {action_name}")
                self.action_history.append(action_name)  # Track executed action
            except Exception as e:
                self.logger.error(f"Error executing action '{action_name}': {e}")
                print(f"An error occurred while executing '{action_name}': {e}")
        else:
            self.logger.warning(f"Action not found in registry: {action_name}")
            print(f"Warning: The action '{action_name}' is not recognized and cannot be executed.")

    def get_user_feedback(self):
        feedback = input("Was this action helpful? (yes/no): ").strip().lower()
        return feedback == 'yes'

    def update_action_history(self):
        """
        Updates the agent's state after an action is executed.
        Tracks executed actions, updates context, and persists state.
        """
        self.logger.info(f"Action History: {self.action_history}")
        
        actions_str = ", ".join(self.action_history)
        self.context += f"Actions taken: {actions_str}\n"
        
        feedback = self.get_user_feedback()
        self.context += f"User Feedback: {'Positive' if feedback else 'Negative'}\n"
        
        state = {
            'context': self.context,
            'action_history': self.action_history
        }
        try:
            with open(self.state_file, 'w', encoding='utf-8') as f:
                json.dump(state, f, indent=4)
            self.logger.info("Agent state successfully saved.")
        except Exception as e:
            self.logger.error(f"Failed to save state: {e}")
    
    def load_acton_history(self):
        """
        Loads the agent's state from a JSON file if it exists.
        """
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, 'r', encoding='utf-8') as f:
                    state = json.load(f)
                self.context = state.get('context', "")
                self.action_history = state.get('action_history', [])
                self.logger.info("Agent state successfully loaded.")
            except Exception as e:
                self.logger.error(f"Failed to load state: {e}")
        else:
            self.logger.info("No existing state file found. Starting fresh.")

    def update_code_files(self, code_files: List[Dict[str, str]]):
        """
        Updates the agent's internal state with new code files.
        
        Args:
            code_files (List[Dict[str, str]]): List of code file dictionaries containing 'file_path' and 'content'.
        """
        if all('file_path' in cf and 'content' in cf for cf in code_files):
            self.code_files = code_files
            logger.debug("Agent's code files updated.")  # {{ edit_12 }}
        else:
            logger.error("Attempted to update code_files with invalid structure.")  # {{ edit_13 }}

    def get_code_files(self) -> List[Dict[str, str]]:
        """
        Retrieves the current code files from the agent's state.
        
        Returns:
            List[Dict[str, str]]: List of code file dictionaries.
        """
        logger.debug(f"Retrieving {len(self.code_files)} code files from agent's state.")  # {{ edit_14 }}
        return self.code_files